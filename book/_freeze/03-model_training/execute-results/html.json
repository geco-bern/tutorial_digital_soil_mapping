{
  "hash": "967c3d828bb85a6c4fb552991fa019f3",
  "result": {
    "markdown": "# Train a Random Forest {#sec-modelfit}\n\n## Load data\n\nIn the previous Chapter, we create a dataframe that holds information on the soil sampling locations and the covariates that we extracted for these positions. Let's load this datafarme into our environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_clean <- readRDS(here::here(\"data/bern_sampling_locations_with_covariates.rds\"))\n\nhead(data_clean) |> knitr::kable()\n```\n\n::: {.cell-output-display}\n|site_id_unique |timeset        |       x|       y|dataset     |dclass   | waterlog.30| waterlog.50| waterlog.100|  ph.0.10| ph.10.30| ph.30.50| ph.50.100| Se_curvplan2m_fmean_50c| Se_tpi_2m_5c| Se_e_aspect2m_5c| mt_tt_y|  Se_SCA2m| Se_curvprof2m_s60| Se_e_aspect25m| Se_curvprof2m_s7|  tsc25_18| Se_curv2m_std_50c| Se_slope2m_fmean_5c| Se_n_aspect2m_5c|   mrrtf25| Se_slope2m_std_50c| Se_curv2m_std_5c|\n|:--------------|:--------------|-------:|-------:|:-----------|:--------|-----------:|-----------:|------------:|--------:|--------:|--------:|---------:|-----------------------:|------------:|----------------:|-------:|---------:|-----------------:|--------------:|----------------:|---------:|-----------------:|-------------------:|----------------:|---------:|------------------:|----------------:|\n|4_26-In-005    |d1968_1974_ptf | 2571994| 1203001|validation  |poor     |           0|           0|            1| 6.071733| 6.227780| 7.109235|  7.214589|              -0.0445323|   -0.0583917|       -0.7929600|      98| 16.248077|        -0.0506380|     -0.9702092|       -0.0732220| 0.3332805|         2.9204133|           0.6683306|       -0.6084610| 0.0184651|          0.8815832|        1.1769447|\n|4_26-In-006    |d1974_1978     | 2572149| 1202965|calibration |poor     |           0|           1|            1| 6.900000| 6.947128| 7.203502|  7.700000|              -0.0501855|    0.0180000|        0.8753148|      98|  3.357315|        -0.1005311|      0.5683194|       -0.4981292| 0.3395441|         3.8783867|           0.9857153|        0.4801802| 0.0544361|          1.0152543|        4.3162045|\n|4_26-In-012    |d1974_1978     | 2572937| 1203693|calibration |moderate |           0|           1|            1| 6.200000| 6.147128| 5.603502|  5.904355|              -0.0079620|   -0.0145804|       -0.3866692|      98| 11.330072|        -0.0125471|     -0.6987815|       -0.0052359| 0.4455501|         0.7022317|           0.5300468|       -0.9221049| 3.6830916|          0.4975456|        0.4170935|\n|4_26-In-014    |d1974_1978     | 2573374| 1203710|validation  |well     |           0|           0|            0| 6.600000| 6.754607| 7.200000|  7.151129|              -0.0301961|   -0.0085602|       -0.8657616|      98| 42.167496|        -0.0400928|     -0.8485889|        0.0529446| 0.4483251|         1.5150748|           0.8635756|       -0.4998477| 0.0075817|          0.5767300|        0.2413423|\n|4_26-In-015    |d1968_1974_ptf | 2573553| 1203935|validation  |moderate |           0|           0|            1| 6.272715| 6.272715| 6.718392|  7.269008|              -0.0179657|    0.0061576|       -0.8864348|      98|  5.479310|        -0.0308456|     -0.8918364|        0.0929077| 0.3974232|         3.6032522|           1.2098556|        0.4614536| 0.0007469|          2.7759163|        1.8169731|\n|4_26-In-016    |d1968_1974_ptf | 2573310| 1204328|calibration |poor     |           0|           0|            1| 6.272715| 6.160700| 5.559031|  5.161655|              -0.0049875|    0.0034276|        0.5905659|      98| 13.499996|        -0.0052602|     -0.8766075|        0.0867119| 0.4278295|         1.5897882|           0.8515157|        0.8054439| 0.0128017|          1.2163279|        0.8171870|\n:::\n:::\n\n\n## Preparations\n\nBefore we can fit the model, we have to specify a few settings. First, we have to specify our response and predictor variables. Then, we have to split our dataset into a calibration and a validation set. Random Forest models cannot deal with `NA` values, so we have to remove these from our calibration set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Specify response: The pH in the top 10cm\nresponse <- \"ph.0.10\"\n\n# Specify predictors: Remove soil sampling information\npredictors <- \n  data_clean |> \n  dplyr::select(-response,                             # Remove response variable\n                -site_id_unique,                       # Remove site ID\n                -tidyr::starts_with(\"ph\"),             # No pH information\n                -tidyr::starts_with(\"waterlog\"),       # No water-status information\n                -dclass,                               # No water-status information\n                -dataset) |>                           # No calib./valid information\n  names()\n\ncat(\"The response is:\", response,\n    \"\\nThe predictors are:\", paste0(predictors[1:8], sep = \", \"), \"...\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe response is: ph.0.10 \nThe predictors are: timeset,  x,  y,  Se_curvplan2m_fmean_50c,  Se_tpi_2m_5c,  Se_e_aspect2m_5c,  mt_tt_y,  Se_SCA2m,  ...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split dataset into calibration and validation\ndata_cal <- data_clean |> dplyr::filter(dataset == \"calibration\")\ndata_val <- data_clean |> dplyr::filter(dataset == \"validation\")\n\n# Filter out any NA to avoid error when running a Random Forest\ndata_cal <- data_cal |> tidyr::drop_na()\ndata_val <- data_val |> tidyr::drop_na()\n\n# A little bit of verbose output:\nn_tot <- nrow(data_cal) + nrow(data_val)\n\nperc_cal <- (nrow(data_cal) / n_tot) |> round(2) * 100\nperc_val <- (nrow(data_val) / n_tot) |> round(2) * 100\n\ncat(\"For model training, we have a calibration / validation split of: \",\n    perc_cal, \"/\", perc_val, \"%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFor model training, we have a calibration / validation split of:  75 / 25 %\n```\n:::\n:::\n\n\nAlright, this looks all good. We have our response and predictor variables saved for easy access later on and the 75/25 split of calibration and validation data looks good too. We can now move on to model fitting!\n\n## Model training\n\nTo fit a Random Forest model that predicts the soil pH in the top 10cm, we are looking at different model setups. These setups always train a Random Forest model but differ in the complexity that we intentionally add to improve the final model. If you need a recap on Random Forests, have a look at the introduction given in AGDS 1.\n\n### Basic model\n\nLet's start with the basic model, where we use the {ranger} package with the pre-defined hyperparameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ranger() crashes when using tibbles, so we are using the\n# base R notation to enter the data\n\nrf_basic <- ranger::ranger( \n  y = data_cal[, response],   # Response variable\n  x = data_cal[, predictors], # Predictor variables\n  seed = 42,                  # Specify the seed for randomization to reproduce the same model again\n  num.threads = parallel::detectCores() - 1) # Use all but one CPU core for quick model training\n\n# Print a summary of fitted model\nrf_basic |> print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRanger result\n\nCall:\n ranger::ranger(y = data_cal[, response], x = data_cal[, predictors],      seed = 42, num.threads = parallel::detectCores() - 1) \n\nType:                             Regression \nNumber of trees:                  500 \nSample size:                      605 \nNumber of independent variables:  18 \nMtry:                             4 \nTarget node size:                 5 \nVariable importance mode:         none \nSplitrule:                        variance \nOOB prediction error (MSE):       0.2716784 \nR squared (OOB):                  0.5401541 \n```\n:::\n:::\n\n\n::: callout-tip\n## Predicting categories with Random Forests\n\nIf our response variable was a categorical and not a continuous variable, we would have to set the argument `probability = TRUE`. The output would then be a probability map from 0-100%.\n:::\n\nAlthough we only used the pre-defined parameters, we already get a fairly good out-of-bag (OOB) $R^2$ of 0.53 and a MSE of 0.28. Let's see how we can improve our model further.\n\n### Model with weights\n\nSometimes we know that a subset of our dataset is more trustworthy than the rest. For example, when you are using a gap-filling technique to interpolate data, that gap-filled data is less trustworthy than the actually measured data. Informing the model algorithm that it should weigh certain data entries more than other can change the importance of variables and the final model performance.\n\nIn our dataset, we have information on whether the pH values were measured in the field - which is less precise - or in the lab. Also, we have to different lab methods. All of this information is held in the suffix of the `timeset` variable, so let's assign weights according on the quality of the pH data as follows: `1` for CaCl$_2$ lab measurement (no suffix), `0.9` for pedotransfer from another lab method (suffix `_ptf`), and `0.7` for field data (suffix `_field`). For this, we create a weight-matching vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweights <- \n  data_cal |>\n  dplyr::mutate(\n    # Create a new variable 'weight' which holds only 1's\n    w = 1,\n    # Check the suffix in each row and if true, give a new weight. If false, keep the old weight.\n    w = ifelse(stringr::str_detect(timeset, \"_field\"), 0.9, w),\n    w = ifelse(stringr::str_detect(timeset, \"_ptf\"), 0.7, w)\n  )\n\n# Quality check if everything worked:\nset.seed(42)\n\nweights |> \n  dplyr::select(timeset, w) |> \n  dplyr::slice_sample(n = 8) |>   # Pick 8 random rows\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n|timeset          |   w|\n|:----------------|---:|\n|d1979_2010       | 1.0|\n|d1968_1974_field | 0.9|\n|d1968_1974_field | 0.9|\n|d1968_1974_field | 0.9|\n|d1968_1974_field | 0.9|\n|d1968_1974_ptf   | 0.7|\n|d1968_1974_field | 0.9|\n|d1968_1974_field | 0.9|\n:::\n:::\n\n\nIt is always a good idea to do quality checks when wrangling! Here we see that our weight attribution code worked as expected, so we can move on to model fitting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_weighted <- ranger::ranger( \n  y = data_cal[, response],      # Response variable\n  x = data_cal[, predictors],    # Predictor variables\n  case.weights = weights[, \"w\"], # Add weights to input\n  seed = 42,                     # Specify seed for randomization to reproduce the same model again\n  num.threads = parallel::detectCores() - 1) # Use all but one CPU core for quick model training\n\n# Print a summary of fitted model\nrf_weighted |> print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRanger result\n\nCall:\n ranger::ranger(y = data_cal[, response], x = data_cal[, predictors],      case.weights = weights[, \"w\"], seed = 42, num.threads = parallel::detectCores() -          1) \n\nType:                             Regression \nNumber of trees:                  500 \nSample size:                      605 \nNumber of independent variables:  18 \nMtry:                             4 \nTarget node size:                 5 \nVariable importance mode:         none \nSplitrule:                        variance \nOOB prediction error (MSE):       0.2717956 \nR squared (OOB):                  0.5399558 \n```\n:::\n:::\n\n\nNot much has changed compared to our previous model. We see that the $R^2$ and MSE got negligibly worse but as a trade-off we gained more trust in our model.\n\n## Model interpretation\n\n### Variable importance based on OOB-Error\n\nOur model has 98 variables but we have no idea if each of them should really be in the model and if we are not just fitting noise in the dataset. To investigate this issue, the `ranger()` function takes an argument called `importance`. We can set this argument either to follow the `permutation` method, whereby the algorithm randomly permutes values of each variable and measures the resulting decrease in model accuracy. A larger decrease indicates a more important variable. If the code runs slow, you can also use the faster `impurity` method (see more information [here](https://bmcbioinformatics.biomedcentral.com/counter/pdf/10.1186/s12859-016-0995-8.pdf)).\n\nAssessing the variable importance gives us a feeling for what variables we should keep or drop from the dataset. The ranger-model stores this information if we enter a `importance` method. The code below accesses the model's variable importance and sorts the variables with decreasing importance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's run the weighted model again but with recording the variable importance\nrf_weighted <- ranger::ranger( \n  y = data_cal[, response],     # Response variable\n  x = data_cal[, predictors],   # Predictor variables\n  case.weights = weights[, \"w\"],# Add weights to input\n  importance   = \"permutation\", # Pick permutation to calculate variable importance\n  seed = 42,                    # Specify seed for randomization to reproduce the same model again\n  num.threads = parallel::detectCores() - 1) # Use all but one CPU core for quick model training\n\n# Extract the variable importance and create a long tibble\nvi_rf_weighted <- \n  rf_weighted$variable.importance |>\n  dplyr::bind_rows() |> \n  tidyr::pivot_longer(cols = dplyr::everything(), names_to = \"variable\")\n\n# Plot variable importance, ordered by decreasing value\np <- \n  vi_rf_weighted |> \n  ggplot2::ggplot(ggplot2::aes(x = reorder(variable, value), y = value)) +\n  ggplot2::geom_bar(stat = \"identity\", fill = \"grey50\", width = 0.75) + \n  ggplot2::labs(\n    y = \"Change in OOB MSE after permutation\", \n    x = \"\",\n    title = \"Change in OOB MSE after permutation\") +\n  ggplot2::theme_classic() +\n  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.5, hjust=1))\n\n# Display plot\np\n```\n\n::: {.cell-output-display}\n![](03-model_training_files/figure-html/unnamed-chunk-7-1.png){width=1152}\n:::\n:::\n\n\nWhat do we see here? The y-axis shows the decrease in model performance when the respective variable is randomly permuted and, therefore, denotes the importance of a variable. The higher the value, the stronger the effect of permutation on the model performance, the more important the variable. Also, we see that a large part of our covariates have practically no power to predict the pH and can therefore be removed from the model. But how do we determine what variable to pick for our final model? Do we want a maximum number of predictors? Do we want a set of the top n predictors that make up a certain percentage of the total variable importance?\n\n### Boruta Algorithm\n\nOne common option to generalize variable selection is the \"Boruta-Algorithm\", which itself is based Random Forests. In essence, the algorithm creates \"shadows\" of your original data, where each of the predictor value is randomly permuted, which destroys the predictive power of the variable. Then, the algorithm iterates over these \"shadows\" and assess for each variable whether its permutation has a substantial effect on the model performance or not. E.g., if a model trained on a variable's shadow performs constantly worse than when trained on the original values, that variable is assessed as important. The algorithm categorizes all variables into \"to reject\", \"to consider\", and \"to keep\". Luckily, we do not have to write this algorithm ourselves but can use the {Boruta} package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nbor <- \n  Boruta::Boruta(\n    y = data_cal[, response], \n    x = data_cal[, predictors],\n    maxRuns = 50, # Number of iterations. Set to 30 or lower if it takes too long\n    num.threads = parallel::detectCores()-1)\n\n# Plot variable importance, the Boruta-output can be directly fed into base R plot()\npar(oma = c(8,3,2,2)) # enlarge plot below for long variable labels\nplot(bor, \n     xlab = \"\", \n     ylab = \"Importance\",\n     las = 2,\n     )\n```\n\n::: {.cell-output-display}\n![](03-model_training_files/figure-html/unnamed-chunk-8-1.png){width=1152}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check whether the most important variables from Boruta-Algorithm are similar as the\n# important variables from the weighted Random Forest model\nbor_top10 <- \n  Boruta::attStats(bor) |> \n  tibble::rownames_to_column() |> \n  dplyr::arrange(dplyr::desc(meanImp)) |> \n  dplyr::slice_head(n = 10) |> \n  dplyr::pull(rowname)\n\nvi_top10 <- \n  vi_rf_weighted |> \n  dplyr::slice_head(n = 10) |> \n  dplyr::pull(variable)\n\ncbind(vi_top10, bor_top10) |> \n  knitr::kable(col.names = c(\"RF Top 10\", \"Boruta Top 10\"))\n```\n\n::: {.cell-output-display}\n|RF Top 10               |Boruta Top 10       |\n|:-----------------------|:-------------------|\n|timeset                 |timeset             |\n|x                       |x                   |\n|y                       |y                   |\n|Se_curvplan2m_fmean_50c |mt_tt_y             |\n|Se_tpi_2m_5c            |tsc25_18            |\n|Se_e_aspect2m_5c        |Se_curv2m_std_5c    |\n|mt_tt_y                 |Se_curv2m_std_50c   |\n|Se_SCA2m                |Se_slope2m_fmean_5c |\n|Se_curvprof2m_s60       |Se_n_aspect2m_5c    |\n|Se_e_aspect25m          |mrrtf25             |\n:::\n:::\n\n\nWe see that apart from the `timeset` variable, the variable importance calculated by the Boruta-Algorithm differs quite a bit, compared to the simple variable importance assessment built into the `ranger()` function. To move forward, we could keep only variables that were classified as \"to keep\" or \"to consider\" by the Boruta-Algorithm:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictors_bor <- \n  bor$finalDecision |> \n  as.data.frame(nm = \"assessment\") |> \n  tibble::rownames_to_column(var = \"variable\") |> \n  dplyr::filter(assessment != \"Rejected\") |> \n  dplyr::pull(variable)\n```\n:::\n\n\nFor this tutorial, we are happy to continue with our most basic Random Forest and save all necessary data as shown below. However, as shown with the model using weights, with the variable selection of the Boruta method, and with applying hyper-parameter tuning and cross-validation for a more robust model, there are many options to create a better model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save relevant data for model testing in the next chapter.\n# Pick rf to save:\nrf <- rf_basic\n\n# Extract predictors used in this rf\npredictors <- rf$forest$independent.variable.names\n\nsaveRDS(rf_basic,                   \n        here::here(\"data/rf_for_ph0-10.rds\"))\n\nsaveRDS(data_cal[, c(response, predictors)],\n        here::here(\"data/cal_for_ph0-10.rds\"))\n\nsaveRDS(data_val[, c(response, predictors)],\n        here::here(\"data/val_for_ph0-10.rds\"))\n```\n:::\n",
    "supporting": [
      "03-model_training_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}