{
  "hash": "8453b5e1ff0d1ef11df727a1598c9368",
  "result": {
    "markdown": "# [Scratchpad] {#sec-exercise}\n\n## Effect of coordinates as predictors\n\n### Functions\n\n#### Model Training\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_basic_rf <- function(coordinates) {\n  \n  # Function check\n  if (!coordinates %in% c(\"none\", \"xy\", \"rotated\")) {\n    stop(\"False call for coordinates!\")  \n  }\n  \n  rm_coord <- c()\n  if (coordinates == \"none\") rm_coord <- c(\"x\", \"y\", \"x30\", \"x60\", \"y30\", \"y60\")\n  if (coordinates == \"xy\")   rm_coord <- c(\"x30\", \"x60\", \"y30\", \"y60\")\n  \n  # Load data\n  data_clean <- readRDS(here::here(\"data/bern_sampling_locations_with_covariates.rds\"))\n  \n  # Specify response: The pH in the top 10cm\n  response <- \"ph.0.10\"\n  \n  # Specify predictors: Remove soil sampling information\n  # NEW: Also remove all coordinate variables\n  predictors <- \n    data_clean |> \n    dplyr::select(\n      -all_of(rm_coord),                    # Remove unwanted coordinates\n      -response,                            # Remove response variable\n      -site_id_unique,                      # Remove site ID\n      -tidyr::starts_with(\"ph\"),            # No pH information\n      -tidyr::starts_with(\"waterlog\"),      # No water-status information\n      -dclass,                              # No water-status information\n      -dataset) |>                          # No calib./valid information\n    names()\n  \n  # Split dataset into calibration and validation\n  data_cal <- data_clean |> dplyr::filter(dataset == \"calibration\")\n  data_val <- data_clean |> dplyr::filter(dataset == \"validation\")\n  \n  # Filter out any NA to avoid error when running a Random Forest\n  data_cal <- data_cal |> tidyr::drop_na()\n  data_val <- data_val |> tidyr::drop_na()\n  \n  # NEW: Remove coordinates from data if needed\n  data_cal <- data_cal |> dplyr::select(response, predictors)\n  data_val <- data_val |> dplyr::select(response, predictors)\n  \n  # Train a basic RF\n  rf <- ranger::ranger( \n    y = data_cal[, response],   # Response variable\n    x = data_cal[, predictors], # Predictor variables\n    importance   = \"permutation\",\n    seed = 42,                  # Specify the seed for randomization to reproduce the same model again\n    num.threads = parallel::detectCores() - 1) # Use all but one CPU core for quick model training\n  \n  return(list(rf = rf,\n              response = response,\n              predictors = predictors,\n              data_clean = data_clean,\n              data_cal = data_cal,\n              data_val = data_val))\n}\n```\n:::\n\n\n\n#### Covariate Data\n\n::: {.cell}\n\n```{.r .cell-code}\nget_cov_data <- function(\n    rf, coordinates){\n  \n  # Load area to be predicted\n  target_raster <- terra::rast(here::here(\"data-raw/geodata/study_area/area_to_be_mapped.tif\"))\n  \n  # Turn target raster into a dataframe, 1 px = 1 cell\n  target_df <- as.data.frame(target_raster, xy = TRUE)\n  \n  # Filter only for area of interest\n  target_df <- target_df |> dplyr::filter(area_to_be_mapped == 1)\n  \n  # Get a list of all covariate file names\n  covariate_files <- \n    list.files(path = here::here(\"data-raw/geodata/covariates/\"), \n               pattern = \".tif$\",\n               recursive = TRUE, \n               full.names = TRUE\n               )\n  \n  # Filter that list only for the variables used in the RF\n  used_cov <- names(rf$variable.importance)\n  cov_to_load <- c()\n  \n  for (i_var in used_cov) {\n    i <- covariate_files[stringr::str_detect(covariate_files, \n                                             paste0(\"/\", i_var, \".tif\"))]\n    cov_to_load <- append(cov_to_load, i)\n    \n    # cat(\"\\nfor var \", i_var, \" load file: \", i)\n  }\n  \n  # Load all rasters as a stack\n  cov_raster <- terra::rast(cov_to_load)\n  \n  # Get coordinates for which we want data\n  sampling_xy <- target_df |> dplyr::select(x, y)\n  \n  # Extract data from covariate raster stack\n  cov_df <-\n    terra::extract(cov_raster,  # The raster we want to extract from\n                   sampling_xy,  # A matrix of x and y values to extract for\n                   ID = FALSE    # To not add a default ID column to the output\n                   )\n  \n  cov_df <- cbind(sampling_xy, cov_df)\n  \n  # Add rotated coordinates as when preparing training data:\n  cov_df <- \n    cov_df |> \n      dplyr::mutate(\n        x30 = x*cos(30/180*pi) - y*sin(30/180*pi),\n        y30 = x*sin(30/180*pi) + y*cos(30/180*pi),\n        x60 = x*cos(60/180*pi) - y*sin(60/180*pi),\n        y60 = x*sin(60/180*pi) + y*cos(60/180*pi)\n      )\n  \n  # Remove coordinates if needed\n  rm_coord <- c()\n  if (coordinates == \"none\") rm_cord <- c(\"x\", \"y\", \"x30\", \"x60\", \"y30\", \"y60\")\n  if (coordinates == \"xy\")   rm_cord <- c(\"x30\", \"x60\", \"y30\", \"y60\")\n  \n  # Remove unwanted\n  cov_df <- cov_df |> dplyr::select(-all_of(rm_coord))\n  \n  # Attaching reference timeset levels from prepared dataset\n  bern_cov <- readRDS(here::here(\"data/bern_sampling_locations_with_covariates.rds\"))\n  cov_df$timeset <- \"d1979_2010\"\n  levels(cov_df$timeset) <- c(unique(bern_cov$timeset))\n  \n  # Define numerically variables \n  cat_vars <- \n    cov_df |> \n    # Get number of distinct values per variable\n    dplyr::summarise(dplyr::across(dplyr::everything(), ~ dplyr::n_distinct(.))) |> \n    # Turn df into long format for easy filtering\n    tidyr::pivot_longer(dplyr::everything(), \n                        names_to = \"variable\", \n                        values_to = \"n\") |> \n    # Filter out variables with 10 or less distinct values\n    dplyr::filter(n <= 10) |>\n    # Extract the names of these variables\n    dplyr::pull('variable')\n  \n  # Define categorical variables \n  cov_df <- \n    cov_df |> \n    dplyr::mutate(dplyr::across(cat_vars, ~ as.factor(.)))\n  \n  # Reduce dataframe to hold only rows without any NA values\n  cov_df <- \n    cov_df |> \n    tidyr::drop_na()\n  \n  return(list(cov_df=cov_df,\n              cov_raster=cov_raster))\n}\n```\n:::\n\n\n#### Get Map\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_prediction_map <- function(\n    rf, cov_df, cov_raster\n    ) {\n  library(ranger) \n  \n  # Make predictions using the RF model\n  prediction <- \n    predict(rf,              # RF model\n            data = cov_df,   # Predictor data\n            num.threads = parallel::detectCores()-1)\n  \n  # Attach predictions to dataframe and round them\n  cov_df$prediction <- round(prediction$predictions, 2)\n  \n  # Extract dataframe with coordinates and predictions\n  df_map <- cov_df |> dplyr::select(x, y, prediction)\n  \n  # Turn dataframe into a raster\n  ra_predictions <- \n    terra::rast(\n      df_map,                  # Table to be transformed\n      crs = \"+init=epsg:2056\", # Swiss coordinate system\n      extent = terra::ext(cov_raster) # Prescribe same extent as predictor rasters\n            )\n  \n  # Let's have a look at our predictions!\n  # To have some more flexibility, we can plot this in the ggplot-style as such:\n  p <- \n    ggplot2::ggplot() +\n    tidyterra::geom_spatraster(data = ra_predictions) +\n    ggplot2::scale_fill_viridis_c(\n      na.value = NA,\n      option = \"viridis\",\n      name = \"pH\"\n      ) +\n    ggplot2::theme_classic() +\n    ggplot2::scale_x_continuous(expand = c(0, 0)) +\n    ggplot2::scale_y_continuous(expand = c(0, 0)) +\n    ggplot2::labs(title = \"Predicted soil pH (0 - 10cm)\")\n  \n  return(p)\n}\n```\n:::\n\n\n\n#### Get Metrics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_modobs_plot <- function(\n    rf, data_val\n    ) {\n  \n  # Need to load {ranger} because ranger-object is used in predict()\n  library(ranger) \n  \n  # Make predictions for validation sites\n  prediction <- \n    predict(rf,                # RF model\n            data = data_val,   # Predictor data\n            num.threads = parallel::detectCores()-1)\n  \n  # Save predictions to validation df\n  data_val$pred <- prediction$predictions\n  \n  # Calculate error\n  err <- data_val$ph.0.10 - data_val$pred\n  \n  # Calculate bias\n  bias <- mean(err, na.rm = T) |> round(2)\n  \n  # Calculate RMSE\n  rmse <- sqrt(mean(err, na.rm = T)) |> round(2)\n  \n  # Calculate R2\n  r2 <- cor(data_val$ph.0.10, data_val$pred, method = \"pearson\")^2 |> round(2)\n  \n  # Make plot\n  p <- \n    data_val |> \n    ggplot2::ggplot(ggplot2::aes(x = pred, y = ph.0.10)) +\n    ggplot2::geom_point() +\n    ggplot2::geom_smooth(method = \"lm\",\n                         color = \"tomato\") +\n    # Add layout\n    ggplot2::theme_classic() +\n    ggplot2::geom_abline(\n      intercept = 0, \n      slope = 1, \n      linetype = \"dotted\") +\n    ggplot2::ylim(5, 7.5) +\n    ggplot2::xlim(5, 7.5) +\n    ggplot2::labs(\n      title = \"Predicted vs. Observed soil pH 0-10 cm\",\n      # subtitle = paste0(\"Bias = \", bias, \", RMSE = \", rmse, \", R^2 = \", r2),\n      subtitle = bquote(paste(\"Bias = \", .(bias), \n                              \", RMSE = \", .(rmse), \n                              \", R\"^2, \" = \", .(r2))),\n      x = \"Predicted\",\n      y = \"Observed\"\n    )\n \n  return(p) \n}\n```\n:::\n\n\n\n## No Coordinates\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoordinates <- \"none\"\nmodel <- train_basic_rf(coordinates = coordinates)\ncovs  <- get_cov_data(rf = model$rf, coordinates = coordinates)\nmap   <- get_prediction_map(rf = model$rf, \n                            cov_df = covs$cov_df, \n                            cov_raster = covs$cov_raster)\nmodobs <- get_modobs_plot(rf = model$rf, \n                          data_val = model$data_val)\n\nmap\n```\n\n::: {.cell-output-display}\n![](99-scratchpad_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmodobs\n```\n\n::: {.cell-output-display}\n![](99-scratchpad_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n## Only xy Coordinates\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoordinates <- \"xy\"\nmodel <- train_basic_rf(coordinates = coordinates)\ncovs  <- get_cov_data(rf = model$rf, coordinates = coordinates)\nmap   <- get_prediction_map(rf = model$rf, \n                            cov_df = covs$cov_df, \n                            cov_raster = covs$cov_raster)\nmodobs <- get_modobs_plot(rf = model$rf, \n                          data_val = model$data_val)\n\nmap\n```\n\n::: {.cell-output-display}\n![](99-scratchpad_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmodobs\n```\n\n::: {.cell-output-display}\n![](99-scratchpad_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n:::\n\n\n## xy and rotated coordinates\n\n::: {.cell}\n\n```{.r .cell-code}\ncoordinates <- \"rotated\"\nmodel <- train_basic_rf(coordinates = coordinates)\ncovs  <- get_cov_data(rf = model$rf, coordinates = coordinates)\nmap   <- get_prediction_map(rf = model$rf, \n                            cov_df = covs$cov_df, \n                            cov_raster = covs$cov_raster)\nmodobs <- get_modobs_plot(rf = model$rf, \n                          data_val = model$data_val)\n\nmap\n```\n\n::: {.cell-output-display}\n![](99-scratchpad_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmodobs\n```\n\n::: {.cell-output-display}\n![](99-scratchpad_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n:::",
    "supporting": [
      "99-scratchpad_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}