{
  "hash": "c9e6e86467ea650d4aaca17147e56616",
  "result": {
    "markdown": "# Model Analysis {#sec-modelanalysis}\n\n## Load model and data\n\nThe trained model, calibration and validation data are loaded.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load random forest model\nrf_bor   <- readRDS(here::here(\"data/rf_for_pH0-10.rds\"))\ndf_train <- readRDS(here::here(\"data/cal_for_ph0-10.rds\"))\ndf_test  <- readRDS(here::here(\"data/val_for_ph0-10.rds\"))\n```\n:::\n\n\nNext, we load a mask of the area over which the soil will be mapped.\nOur target area to predict over is defined in the file `area_to_be_mapped.tif`. Since we only want to predict on a given study area, the TIF file comes with a labeling of `0` for pixels that are outside the area of interest and `1` for pixels within the area of interest.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load area to be predicted\nraster_mask <- terra::rast(here::here(\"data-raw/geodata/study_area/area_to_be_mapped.tif\"))\n\n# Turn target raster into a dataframe, 1 px = 1 cell\ndf_mask <- as.data.frame(raster_mask, xy = TRUE)\n\n# Filter only for area of interest\ndf_mask <- df_mask |> \n  dplyr::filter(area_to_be_mapped == 1)\n\n# Display df\nhead(df_mask) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n|       x|       y| area_to_be_mapped|\n|-------:|-------:|-----------------:|\n| 2587670| 1219750|                 1|\n| 2587690| 1219750|                 1|\n| 2587090| 1219190|                 1|\n| 2587090| 1219170|                 1|\n| 2587110| 1219170|                 1|\n| 2587070| 1219150|                 1|\n:::\n:::\n\n\nNext, we have to load the selected set of covariates as maps. These will be as the basis for spatial upscaling and provide the predictor values across space, fed into the trained model for predicting soil pH across space.\n\nGet a list of all available covariate file names.\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles_covariates <- list.files(\n  path = here::here(\"data-raw/geodata/covariates/\"), \n  pattern = \".tif$\",\n  recursive = TRUE, \n  full.names = TRUE\n  )\n```\n:::\n\n\nNote that the predictor rasters have to have the same resolution, extent, and coordinate reference system. This is the case as shown for two randomly picked examples.\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_files <- sample(files_covariates, 2)\nterra::rast(random_files[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 986, 2428, 1  (nrow, ncol, nlyr)\nresolution  : 20, 20  (x, y)\nextent      : 2568140, 2616700, 1200740, 1220460  (xmin, xmax, ymin, ymax)\ncoord. ref. : CH1903+ / LV95 \nsource      : Se_curv2m_std_50c.tif \nname        : Se_curv2m_std_50c \nmin value   :            0.0000 \nmax value   :          213.5755 \n```\n:::\n\n```{.r .cell-code}\nterra::rast(random_files[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 986, 2428, 1  (nrow, ncol, nlyr)\nresolution  : 20, 20  (x, y)\nextent      : 2568140, 2616700, 1200740, 1220460  (xmin, xmax, ymin, ymax)\ncoord. ref. : CH1903+ / LV95 \nsource      : Se_rough2m_rect3c.tif \nname        : Se_rough2m_rect3c \nmin value   :          0.000000 \nmax value   :          4.593187 \n```\n:::\n:::\n\n\nLoad the rasters for the selected predictor variables into a raster object (a \"stack\" of multiple rasters).\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter that list only for the variables used in the RF\npreds_selected <- names(rf_bor$forest$covariate.levels)\nfiles_selected <- files_covariates[apply(sapply(X = preds_selected, \n                                            FUN = grepl, \n                                            files_covariates), \n                                     MARGIN =  1, \n                                     FUN = any)]\n\n# Load all rasters as a stack\nraster_covariates <- terra::rast(files_selected)\n```\n:::\n\n\nConvert the raster stack into a dataframe - the preferred format for model prediction.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get coordinates for which we want data\ndf_locations <- df_mask |> \n  dplyr::select(x, y)\n\n# Extract data from covariate raster stack for all gridcells in the raster\ndf_predict <- terra::extract(\n  raster_covariates,   # The raster we want to extract from\n  df_locations,        # A matrix of x and y values to extract for\n  ID = FALSE           # To not add a default ID column to the output\n  )\n\ndf_predict <- cbind(df_locations, df_predict) |> \n  tidyr::drop_na()  # Se_TWI2m has a small number of missing data\n```\n:::\n\n\n## Model testing\n\n### Make predictions\n\nTo test our model for how well it predicts on data it has not used during model training, we first have to load the {ranger} package to load all functionalities to run a Random Forest with the `predict()` function. Alongside our model, we feed our validation data into the function and set its parallelization settings to use all but one of our computer's cores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Need to load {ranger} because ranger-object is used in predict()\nlibrary(ranger) \n\n# Make predictions for validation sites\nprediction <- predict(\n  rf_bor,           # RF model\n  data = df_test,   # Predictor data\n  num.threads = parallel::detectCores() - 1\n  )\n\n# Save predictions to validation df\ndf_test$pred <- prediction$predictions\n```\n:::\n\n\n### Model metrics\n\nNow that we have our predictions ready, we can extract standard metrics for a classification problem (see [AGDS Chapter 8.2.2](https://geco-bern.github.io/agds/regressionclassification.html#regression)).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate error\nerr <- df_test$ph.0.10 - df_test$pred\n\n# Calculate bias\nbias <- mean(err, na.rm = TRUE) |> round(2)\n\n# Calculate RMSE\nrmse <- sqrt(mean(err, na.rm = TRUE)) |> round(2)\n\n# Calculate R2\nr2 <- cor(df_test$ph.0.10, df_test$pred, method = \"pearson\")^2 |> round(2)\n```\n:::\n\n\n### Metric plots\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_test |> \n  ggplot2::ggplot(ggplot2::aes(x = pred, y = ph.0.10)) +\n  ggplot2::geom_point() +\n  ggplot2::geom_smooth(method = \"lm\",\n                       color = \"tomato\") +\n  ggplot2::theme_classic() +\n  ggplot2::geom_abline(\n    intercept = 0, \n    slope = 1, \n    linetype = \"dotted\") +\n  ggplot2::ylim(5, 7.5) +\n  ggplot2::xlim(5, 7.5) +\n  ggplot2::labs(\n    title = \"Predicted vs. Observed soil pH 0-10 cm\",\n    subtitle = bquote(paste(\"Bias = \", .(bias), \n                            \", RMSE = \", .(rmse), \n                            \", R\"^2, \" = \", .(r2))),\n    x = \"Predicted pH\",\n    y = \"Observed pH\"\n  )\n```\n\n::: {.cell-output-display}\n![Comparison of observed versus predicted values for top soil pH using a simple Random Forest model.](04-model_test_files/figure-html/fig-ph-modobs-1.png){#fig-ph-modobs width=672}\n:::\n:::\n\n\nThe plot shows that our model explains about half of the observed variation in soil pH. Yet, we can also see that the model tends to overestimate low pH values. Anyways, let's move ahead.\n\n## Create prediction maps\n\nThe fitted and tested model can now be used for spatially upscaling - creating a map of top soil pH values across our study area. For this, we again make predictions with our Random Forest model but we use our covariates dataframe for the study area, instead of only at the sampling locations as done above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make predictions using the RF model\nprediction <- predict(\n  rf_bor,              # RF model\n  data = df_predict,   \n  num.threads = parallel::detectCores() - 1)\n\n# Attach predictions to dataframe and round them\ndf_predict$prediction <- prediction$predictions\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract dataframe with coordinates and predictions\ndf_map <- df_predict |>\n  dplyr::select(x, y, prediction)\n\n# Turn dataframe into a raster\nraster_pred <- terra::rast(\n  df_map,                  # Table to be transformed\n  crs = \"+init=epsg:2056\", # Swiss coordinate system\n  extent = terra::ext(raster_covariates) # Prescribe same extent as predictor rasters\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's have a look at our predictions!\n# To have some more flexibility, we can plot this in the ggplot-style as such:\nggplot2::ggplot() +\n  tidyterra::geom_spatraster(data = raster_pred) +\n  ggplot2::scale_fill_viridis_c(\n    na.value = NA,\n    option = \"viridis\",\n    name = \"pH\"\n    ) +\n  ggplot2::theme_classic() +\n  ggplot2::scale_x_continuous(expand = c(0, 0)) +\n  ggplot2::scale_y_continuous(expand = c(0, 0)) +\n  ggplot2::labs(title = \"Predicted soil pH (0 - 10cm)\")\n```\n\n::: {.cell-output-display}\n![Predicted map of top soil pH using a simple Random Forest model.](04-model_test_files/figure-html/fig-ph-prediction-map-1.png){#fig-ph-prediction-map width=672}\n:::\n:::\n\n\nInteresting, we see that in this study area, there is a tendency of having more acidic soils towards the south west and more basic soils towards the north east. \n\nLet's write the predicted top soil pH raster into a GeoTIFF file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save raster as .tif file\nterra::writeRaster(\n  raster_pred,\n  \"../data/ra_predicted_ph0-10.tif\",\n  datatype = \"FLT4S\",  # FLT4S for floats, INT1U for integers (smaller file)\n  filetype = \"GTiff\",  # GeoTiff format\n  overwrite = TRUE     # Overwrite existing file\n)\n```\n:::\n\n\nThat's it.\n",
    "supporting": [
      "04-model_test_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}